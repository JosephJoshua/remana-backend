// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: repair_order.sql

package gensql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type AddCostsToRepairOrderParams struct {
	RepairOrderCostID pgtype.UUID
	RepairOrderID     pgtype.UUID
	Amount            int32
	Reason            pgtype.Text
	CreationTime      pgtype.Timestamptz
}

type AddDamagesToRepairOrderParams struct {
	RepairOrderDamageID pgtype.UUID
	RepairOrderID       pgtype.UUID
	DamageName          string
}

type AddPhoneConditionsToRepairOrderParams struct {
	RepairOrderPhoneConditionID pgtype.UUID
	RepairOrderID               pgtype.UUID
	PhoneConditionName          string
}

type AddPhoneEquipmentsToRepairOrderParams struct {
	RepairOrderPhoneEquipmentID pgtype.UUID
	RepairOrderID               pgtype.UUID
	PhoneEquipmentName          string
}

type AddPhotosToRepairOrderParams struct {
	RepairOrderPhotoID pgtype.UUID
	RepairOrderID      pgtype.UUID
	PhotoUrl           string
}

const createRepairOrder = `-- name: CreateRepairOrder :exec
INSERT INTO repair_orders (
  repair_order_id,
  creation_time,
  slug,
  store_id,
  customer_name,
  contact_number,
  phone_type,
  color,
  sales_id,
  technician_id,
  imei,
  parts_not_checked_yet,
  passcode_or_pattern,
  is_pattern_locked,
  down_payment_amount,
  down_payment_method_id
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11,
  $12,
  $13,
  $14,
  $15,
  $16
)
`

type CreateRepairOrderParams struct {
	RepairOrderID       pgtype.UUID
	CreationTime        pgtype.Timestamptz
	Slug                string
	StoreID             pgtype.UUID
	CustomerName        string
	ContactNumber       string
	PhoneType           string
	Color               string
	SalesID             pgtype.UUID
	TechnicianID        pgtype.UUID
	Imei                pgtype.Text
	PartsNotCheckedYet  pgtype.Text
	PasscodeOrPattern   pgtype.Text
	IsPatternLocked     pgtype.Bool
	DownPaymentAmount   pgtype.Int4
	DownPaymentMethodID pgtype.UUID
}

func (q *Queries) CreateRepairOrder(ctx context.Context, arg CreateRepairOrderParams) error {
	_, err := q.db.Exec(ctx, createRepairOrder,
		arg.RepairOrderID,
		arg.CreationTime,
		arg.Slug,
		arg.StoreID,
		arg.CustomerName,
		arg.ContactNumber,
		arg.PhoneType,
		arg.Color,
		arg.SalesID,
		arg.TechnicianID,
		arg.Imei,
		arg.PartsNotCheckedYet,
		arg.PasscodeOrPattern,
		arg.IsPatternLocked,
		arg.DownPaymentAmount,
		arg.DownPaymentMethodID,
	)
	return err
}

const doesPaymentMethodExist = `-- name: DoesPaymentMethodExist :one
SELECT 1
FROM payment_methods
WHERE payment_methods.store_id = $1 AND payment_methods.payment_method_id = $2
`

type DoesPaymentMethodExistParams struct {
	StoreID         pgtype.UUID
	PaymentMethodID pgtype.UUID
}

func (q *Queries) DoesPaymentMethodExist(ctx context.Context, arg DoesPaymentMethodExistParams) (int32, error) {
	row := q.db.QueryRow(ctx, doesPaymentMethodExist, arg.StoreID, arg.PaymentMethodID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const doesSalesExist = `-- name: DoesSalesExist :one
SELECT 1
FROM sales
WHERE sales.store_id = $1 AND sales.sales_id = $2
`

type DoesSalesExistParams struct {
	StoreID pgtype.UUID
	SalesID pgtype.UUID
}

func (q *Queries) DoesSalesExist(ctx context.Context, arg DoesSalesExistParams) (int32, error) {
	row := q.db.QueryRow(ctx, doesSalesExist, arg.StoreID, arg.SalesID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const doesTechnicianExist = `-- name: DoesTechnicianExist :one
SELECT 1
FROM technicians
WHERE technicians.store_id = $1 AND technicians.technician_id = $2
`

type DoesTechnicianExistParams struct {
	StoreID      pgtype.UUID
	TechnicianID pgtype.UUID
}

func (q *Queries) DoesTechnicianExist(ctx context.Context, arg DoesTechnicianExistParams) (int32, error) {
	row := q.db.QueryRow(ctx, doesTechnicianExist, arg.StoreID, arg.TechnicianID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const getDamageNamesByIDs = `-- name: GetDamageNamesByIDs :many
SELECT damage_types.damage_type_name
FROM damage_types
WHERE damage_types.store_id = $1 AND damage_types.damage_type_id = ANY($2::UUID[])
`

type GetDamageNamesByIDsParams struct {
	StoreID pgtype.UUID
	Ids     []pgtype.UUID
}

func (q *Queries) GetDamageNamesByIDs(ctx context.Context, arg GetDamageNamesByIDsParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getDamageNamesByIDs, arg.StoreID, arg.Ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var damage_type_name string
		if err := rows.Scan(&damage_type_name); err != nil {
			return nil, err
		}
		items = append(items, damage_type_name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPhoneConditionNamesByIDs = `-- name: GetPhoneConditionNamesByIDs :many
SELECT phone_conditions.phone_condition_name
FROM phone_conditions
WHERE phone_conditions.store_id = $1 AND phone_conditions.phone_condition_id = ANY($2::UUID[])
`

type GetPhoneConditionNamesByIDsParams struct {
	StoreID pgtype.UUID
	Ids     []pgtype.UUID
}

func (q *Queries) GetPhoneConditionNamesByIDs(ctx context.Context, arg GetPhoneConditionNamesByIDsParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getPhoneConditionNamesByIDs, arg.StoreID, arg.Ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var phone_condition_name string
		if err := rows.Scan(&phone_condition_name); err != nil {
			return nil, err
		}
		items = append(items, phone_condition_name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPhoneEquipmentNamesByIDs = `-- name: GetPhoneEquipmentNamesByIDs :many
SELECT phone_equipments.phone_equipment_name
FROM phone_equipments
WHERE phone_equipments.store_id = $1 AND phone_equipments.phone_equipment_id = ANY($2::UUID[])
`

type GetPhoneEquipmentNamesByIDsParams struct {
	StoreID pgtype.UUID
	Ids     []pgtype.UUID
}

func (q *Queries) GetPhoneEquipmentNamesByIDs(ctx context.Context, arg GetPhoneEquipmentNamesByIDsParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getPhoneEquipmentNamesByIDs, arg.StoreID, arg.Ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var phone_equipment_name string
		if err := rows.Scan(&phone_equipment_name); err != nil {
			return nil, err
		}
		items = append(items, phone_equipment_name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isRepairOrderSlugTaken = `-- name: IsRepairOrderSlugTaken :one
SELECT 1
FROM repair_orders
WHERE repair_orders.store_id = $1 AND repair_orders.slug = $2
`

type IsRepairOrderSlugTakenParams struct {
	StoreID pgtype.UUID
	Slug    string
}

func (q *Queries) IsRepairOrderSlugTaken(ctx context.Context, arg IsRepairOrderSlugTakenParams) (int32, error) {
	row := q.db.QueryRow(ctx, isRepairOrderSlugTaken, arg.StoreID, arg.Slug)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}
